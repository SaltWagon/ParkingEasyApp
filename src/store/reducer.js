import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';

const initialState = {
    filters: {
        distance: '',
        startTime: '',
        endTime: '',
        startDate: '',
        endDate: '',
        carparkType: '',
        paymentType: '',
        showRates: '',
        long: '',
        lat: '',
        currentLong: '',
        currentLat: '',
        startEpoch: '',
        endEpoch: '',
        endMinEpoch: '',
        maxTimeEpoch: '',
    },
    distance: '',
    startTime: '',
    endTime: '',
    startDate: '',
    endDate: '',
    carparkType: '',
    paymentType: '',
    showRates: '',
    long: '',
    lat: '',
    currentLong: '',
    currentLat: '',
    startEpoch: '',
    endEpoch: '',
    endMinEpoch: '',
    maxTimeEpoch: '',
}

// // The function below is called a thunk and allows us to perform async logic. It
// // can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// // will call the thunk with the `dispatch` function as the first argument. Async
// // code can then be executed and other actions can be dispatched. Thunks are
// // typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
//     'counter/fetchCount',
//     async (amount) => {
//         const response = await fetchCount(amount);
//         // The value we return becomes the `fulfilled` action payload
//         return response.data;
//     }
// );

export const filterSlice = createSlice({
    name: 'filter',
    initialState,
    // The `reducers` field lets us define reducers and generate associated actions
    reducers: {
        setDistance: (state, action) => {
            // Redux Toolkit allows us to write "mutating" logic in reducers. It
            // doesn't actually mutate the state because it uses the Immer library,
            // which detects changes to a "draft state" and produces a brand new
            // immutable state based off those changes
            state.distance = action.payload;
        },
        setStartTime: (state, action) => {
            state.startTime = action.payload;
        },
        setEndTime: (state, action) => {
            state.endTime = action.payload;
        },
        setStartDate: (state, action) => {
            state.startDate = action.payload;
        },
        setEndDate: (state, action) => {
            state.endDate = action.payload;
        },
        setCarparkType: (state, action) => {
            state.carparkType = action.payload;
        },
        setPaymentType: (state, action) => {
            state.paymentType = action.payload;
        },
        setShowRates: (state, action) => {
            state.showRates = action.payload;
        },
        setLong: (state, action) => {
            state.long = action.payload;
        },
        setLat: (state, action) => {
            state.lat = action.payload;
        },
        setCurrentLong: (state, action) => {
            state.currentLong = action.payload;
        },
        setCurrentLat: (state, action) => {
            state.currentLat = action.payload;
        },
        setStartEpoch: (state, action) => {
            state.startEpoch = action.payload;
        },
        setEndEpoch: (state, action) => {
            state.endEpoch = action.payload;
        },
        setEndMinEpoch: (state, action) => {
            state.endMinEpoch = action.payload;
        },
        // Use the PayloadAction type to declare the contents of `action.payload`
        setFilters: (state, action) => {
            state.filters = action.payload;
        },
    },
    // The `extraReducers` field lets the slice handle actions defined elsewhere,
    // including actions generated by createAsyncThunk or in other slices.
    // extraReducers: (builder) => {
    //     builder
    //         .addCase(incrementAsync.pending, (state) => {
    //             state.status = 'loading';
    //         })
    //         .addCase(incrementAsync.fulfilled, (state, action) => {
    //             state.status = 'idle';
    //             state.value += action.payload;
    //         });
    // },
});

export const {
    setDistance,
    setStartTime,
    setEndTime,
    setStartDate,
    setEndDate,
    setCarparkType,
    setPaymentType,
    setShowRates,
    setLong,
    setLat,
    setCurrentLong,
    setCurrentLat,
    setStartEpoch,
    setEndEpoch,
    setEndMinEpoch,
    setFilters
} = filterSlice.actions;

// // The function below is called a selector and allows us to select a value from
// // the state. Selectors can also be defined inline where they're used instead of
// // in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
// export const selectCount = (state) => state.counter.value;
export const selectFilters = (state) => state.filter.filters;
export const selectDistance = (state) => state.filter.distance;
export const selectStartTime = (state) => state.filter.startTime;
export const selectEndTime = (state) => state.filter.endTime;
export const selectStartDate = (state) => state.filter.startDate;
export const selectEndDate = (state) => state.filter.endDate;
export const selectCarparkType = (state) => state.filter.carparkType;
export const selectPaymentType = (state) => state.filter.paymentType;
export const selectShowRates = (state) => state.filter.showRates;
export const selectLong = (state) => state.filter.long;
export const selectLat = (state) => state.filter.lat;
export const selectCurrentLong = (state) => state.filter.currentLong;
export const selectCurrentLat = (state) => state.filter.currentLat;
export const selectStartEpoch = (state) => state.filter.startEpoch;
export const selectEndEpoch = (state) => state.filter.endEpoch;
export const selectEndMinEpoch = (state) => state.filter.endMinEpoch;

// // We can also write thunks by hand, which may contain both sync and async logic.
// // Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd = (amount) => (dispatch, getState) => {
//     const currentValue = selectCount(getState());
//     if (currentValue % 2 === 1) {
//         dispatch(incrementByAmount(amount));
//     }
// };

export default filterSlice.reducer;